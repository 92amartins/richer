---
title: "Modeling"
output: html_notebook
---

Nesse notebook, vamos coletar os dados da `VALE3`, criar conjuntos de treinamento,
validação e teste e, por fim, criar uma regressão linear para prever o preço do próximo
mês.

## Carregando pacotes
```{r}
library(tidyverse)
library(lubridate)
library(convexity)
```
## Coletando dados

```{r, warning=FALSE, echo=FALSE}
raw_vale = stock("VALE3.SA")
raw_vale
```

## Preço médio por mês
```{r message=FALSE}
vale <- raw_vale %>%
  mutate(date = rownames(raw_vale)) %>%
  mutate(month = month(date), year = year(date)) %>%
  group_by(year, month) %>%
  summarise(mean_closing_price = mean(VALE3.SA.Close, na.rm = TRUE)) %>%
  mutate(date = date(paste0(year, "-", month, "-", "01"))) %>%
  ungroup()
vale
```

A `VALE3` está há 165 meses na bolsa de São Paulo (~13 anos). O gráfico abaixo mostra
o preço médio de fechamento ao longo desses meses.

```{r}
ggplot(vale) +
  geom_line(aes(x=date, y=mean_closing_price))
```

## Treino, Validação e Teste

Para garantir que o nosso modelo faça boas previsões, vamos adotar o esquema de split [train-dev-test](https://medium.com/swlh/12-steps-to-applied-ai-2fdad7fdcdf3). Neste modelo, 70% dos dados são destinados ao treino, 20% à validação e 10% ao teste final.

Essa divisão nos dará 9 anos de treinamento, 2 anos de validação e 1 ano para o teste final.
Ao invés de fazer amostragem aleatória, vamos respeitar o tempo e separar os conjuntos de dados respeitando a ordem temporal. Isso nos dará:

| conjunto   | data      |
|:----------:|:---------:|
| treino     | 2007-2016 |
| validação  | 2017-2019 |
| teste      |      2020 |

```{r}
splits <- vale %>%
  mutate(set = case_when(year <= 2017 ~ "train",
                         year < 2020 ~ "validation",
                         TRUE ~ "test"))
ggplot(splits) +
  geom_line(aes(x=date, y=mean_closing_price, color=set))
```

## Modelo ingênuo

Vamos implementar um modelo bastante ingênuo que se baseia no *preço médio do mês anterior* para fazer a previsão do valor médio da ação no mês seguinte.

Para isso, primeiro será necessário "computar" o preço médio do mês anterior:

```{r}
lagged <- splits %>%
  mutate(previous_closing_price = lag(mean_closing_price))
lagged %>%
  select(date, previous_closing_price, mean_closing_price, set)
```

```{r}
train <- lagged %>% filter(set == "train")
model <- lm(mean_closing_price ~ previous_closing_price, data=train)
summary(model)
```
O modelo resultante é:

$$\hat{y} = 0.96x + 1.29$$

em que x representa o preço médio no mês anterior e $\hat{y}$ é o valor previsto para o mês em questão.

## Avaliação do modelo

Vamos avaliar o quão bem o modelo que criamos está prevendo o preço médio no próximo mês.

```{r}
validation = lagged %>% filter(set == "validation")

predictions <- validation %>%
  mutate(predicted_price = predict(model, newdata=validation)) %>%
  mutate(diff = predicted_price - previous_closing_price)
predictions
```
```{r}
ggplot(predictions) +
  geom_line(aes(x=date, y=predicted_price)) +
  geom_line(aes(x=date, y=mean_closing_price), linetype="dashed")
```
